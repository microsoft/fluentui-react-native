#!/usr/bin/env node

/**
 * Generates PR body for version bump PRs with size management
 * Implements 3-tier progressive fallback to handle GitHub's 65k character limit
 */

import { execSync } from 'child_process';
import { readFileSync, existsSync } from 'fs';
import { join } from 'path';

const GITHUB_PR_BODY_LIMIT = 65536;
const SAFETY_MARGIN = 1000;
const MAX_SIZE = GITHUB_PR_BODY_LIMIT - SAFETY_MARGIN;

interface VersionChange {
  package: string;
  oldVersion: string;
  newVersion: string;
  changeType: 'major' | 'minor' | 'patch';
  changelogPath: string;
}

interface PRBodyResult {
  body: string;
  size: number;
  tier: 'full' | 'summary' | 'minimal';
  truncated: boolean;
}

/**
 * Extracts version changes from git diff
 */
function getVersionChanges(): VersionChange[] {
  const modifiedFiles = execSync('git diff --name-only HEAD', { encoding: 'utf8' })
    .split('\n')
    .filter(f => f.includes('package.json') && f !== 'package.json');

  const changes: VersionChange[] = [];

  for (const file of modifiedFiles) {
    try {
      const oldContent = execSync(`git show HEAD:${file}`, { encoding: 'utf8' });
      const newContent = readFileSync(file, 'utf8');

      const oldPkg = JSON.parse(oldContent);
      const newPkg = JSON.parse(newContent);

      // Only include if version changed and package is public
      if (oldPkg.version !== newPkg.version && !newPkg.private) {
        const changeType = detectChangeType(oldPkg.version, newPkg.version);
        const changelogPath = join(file, '..', 'CHANGELOG.md').replace(/\/package\.json\/\.\.\//, '/');

        changes.push({
          package: newPkg.name,
          oldVersion: oldPkg.version,
          newVersion: newPkg.version,
          changeType,
          changelogPath,
        });
      }
    } catch (error) {
      // Skip files that can't be read
      console.error(`‚ö†Ô∏è  Warning: Could not read ${file}`);
    }
  }

  // Sort: major first, then minor, then patch
  const order = { major: 0, minor: 1, patch: 2 };
  changes.sort((a, b) => order[a.changeType] - order[b.changeType]);

  return changes;
}

/**
 * Detects change type based on version diff
 */
function detectChangeType(oldVersion: string, newVersion: string): 'major' | 'minor' | 'patch' {
  const oldParts = oldVersion.split('.').map(Number);
  const newParts = newVersion.split('.').map(Number);

  if (newParts[0] > oldParts[0]) return 'major';
  if (newParts[1] > oldParts[1]) return 'minor';
  return 'patch';
}

/**
 * Extracts changelog section for a specific version
 */
function extractChangelog(changelogPath: string, version: string): string | null {
  if (!existsSync(changelogPath)) {
    return null;
  }

  try {
    const content = readFileSync(changelogPath, 'utf8');
    // Match version section: ## version ... until next ## or end of file
    const versionEscaped = version.replace(/\./g, '\\.');
    const regex = new RegExp(`## ${versionEscaped}[\\s\\S]*?(?=\\n## |$)`, 'i');
    const match = content.match(regex);

    if (match) {
      // Truncate if too long (keep first 500 chars)
      const section = match[0].trim();
      return section.length > 500 ? section.substring(0, 500) + '...' : section;
    }
  } catch (error) {
    // Ignore errors
  }

  return null;
}

/**
 * Tier 1: Full changelog with all details
 */
function generateFullChangelog(changes: VersionChange[]): string {
  const header = `## Version Bump

This PR was automatically generated by Azure Pipelines.

### Changed Packages (${changes.length})

`;

  const packageDetails = changes.map(change => {
    const changelog = extractChangelog(change.changelogPath, change.newVersion);
    let details = `#### ${change.package}

**Version:** ${change.oldVersion} ‚Üí ${change.newVersion}
**Type:** ${change.changeType}

`;

    if (changelog) {
      details += `**Changes:**\n${changelog}\n\n`;
    }

    return details;
  }).join('\n');

  const footer = `### What to do next:
1. Review the version changes and CHANGELOG.md files
2. Merge this PR when ready
3. Azure Pipelines will automatically publish to NPM

**Note:** Once merged, Azure Pipelines will detect the version changes and publish to NPM.
`;

  return header + packageDetails + footer;
}

/**
 * Tier 2: Package list only (no changelog content)
 */
function generateSummaryChangelog(changes: VersionChange[]): string {
  const majorChanges = changes.filter(c => c.changeType === 'major');
  const minorChanges = changes.filter(c => c.changeType === 'minor');
  const patchChanges = changes.filter(c => c.changeType === 'patch');

  let body = `## Version Bump

This PR was automatically generated by Azure Pipelines.

### Summary
- **${changes.length} packages** will be updated

`;

  if (majorChanges.length > 0) {
    body += `\n### ‚ö†Ô∏è Major Changes (${majorChanges.length})\n`;
    majorChanges.forEach(c => {
      body += `- **${c.package}**: ${c.oldVersion} ‚Üí ${c.newVersion}\n`;
    });
  }

  if (minorChanges.length > 0) {
    body += `\n### ‚ú® Minor Changes (${minorChanges.length})\n`;
    minorChanges.forEach(c => {
      body += `- ${c.package}: ${c.oldVersion} ‚Üí ${c.newVersion}\n`;
    });
  }

  if (patchChanges.length > 0) {
    body += `\n### üêõ Patch Changes (${patchChanges.length})\n`;
    patchChanges.forEach(c => {
      body += `- ${c.package}: ${c.oldVersion} ‚Üí ${c.newVersion}\n`;
    });
  }

  body += `
**Note:** Full changelog details were too large for PR body.
See individual CHANGELOG.md files in the commit for complete details.

### What to do next:
1. Review the version changes and CHANGELOG.md files
2. Merge this PR when ready
3. Azure Pipelines will automatically publish to NPM
`;

  return body;
}

/**
 * Tier 3: Minimal (package count only)
 */
function generateMinimalChangelog(changes: VersionChange[]): string {
  return `## Version Bump

This PR was automatically generated by Azure Pipelines.

### Summary
- **${changes.length} packages** will be updated
- See commit diff for full details of version changes and changelogs

### What to do next:
1. Review the version changes in the commit
2. Check CHANGELOG.md files for each package
3. Merge this PR when ready
4. Azure Pipelines will automatically publish to NPM

**Note:** Changelog was too large to include in PR body.
View the commit diff for complete version and changelog information.
`;
}

/**
 * Generates PR body with progressive fallback
 */
function generatePRBody(changes: VersionChange[]): PRBodyResult {
  if (changes.length === 0) {
    return {
      body: `## Version Bump

No public packages were updated in this change.`,
      size: 0,
      tier: 'minimal',
      truncated: false,
    };
  }

  // Try tier 1: Full changelog
  let body = generateFullChangelog(changes);
  if (body.length <= MAX_SIZE) {
    return {
      body,
      size: body.length,
      tier: 'full',
      truncated: false,
    };
  }

  console.error(`‚ö†Ô∏è  PR body too large (${body.length} chars), falling back to summary`);

  // Try tier 2: Summary only
  body = generateSummaryChangelog(changes);
  if (body.length <= MAX_SIZE) {
    return {
      body,
      size: body.length,
      tier: 'summary',
      truncated: true,
    };
  }

  console.error(`‚ö†Ô∏è  PR body still too large (${body.length} chars), falling back to minimal`);

  // Tier 3: Minimal
  body = generateMinimalChangelog(changes);
  return {
    body,
    size: body.length,
    tier: 'minimal',
    truncated: true,
  };
}

/**
 * Main function
 */
function main(): void {
  try {
    const changes = getVersionChanges();

    console.error(`üì¶ Found ${changes.length} package(s) with version changes`);
    changes.forEach(c => {
      console.error(`  - ${c.package}: ${c.oldVersion} ‚Üí ${c.newVersion} (${c.changeType})`);
    });

    const result = generatePRBody(changes);

    console.error(`\n‚úÖ Generated ${result.tier} PR body (${result.size} chars)`);
    if (result.truncated) {
      console.error(`‚ö†Ô∏è  Content was truncated due to size limits`);
    }

    // Output PR body to stdout
    console.log(result.body);
  } catch (error) {
    console.error(`‚ùå Error generating PR body: ${(error as Error).message}`);
    process.exit(1);
  }
}

main();
